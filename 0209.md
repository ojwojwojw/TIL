# 브루트 포스 
```
p = 'isnot'   #찾을 패턴
t = 'this isnot a book' #전체 텍스트
M = len(p)    #찾을패턴의 길이
N = len(t)    #전체 텍스트의 길이

def BruteForce (p,t):
    i = 0    #t의 인덱스
    j = 0   #p의 인덱스
    while j < M and i < N:  #비교할 문장이 남아있고 패턴을 찾기 전이면
        if t[i] != p[j]:    # 서로 다른 글자를 만나면
            i = i-j      # 비교를 시작한 위치로
            j = -1       # 패턴의 시작 전으로
        i = i+ 1
        j = j+ 1

    if j ==M:
        return i-M   #검색 성공
    else:
        return -1    #검색실패

print(BruteForce(p,t))
```
- 처음에 코드만 접했을땐 뭘 하려는건지 몰랐다
- 하지만 문자열에 특정 문자열이 포함되는지를 검사하는 목적을 알고나서 보니 
- 인덱스가 어떤식으로 돌아가서 무슨일이 일어나는지 알 수 있었다
- 13열에 i=i-j를 통해서 특정 문자열을 j만큼 검사 했더라도, 다시 i를 검사 처음 위치로 돌려보낼수 있다.
- 14열에 j를 -1로 설정한것은, i와 j를 15,16행에서 계속 1씩 더해주는 연산을 하는것을 고려해서 
- j가 반복이 한번 끝날때 마다 0으로 초기화 될 수 있게끔 한 것이였다.
